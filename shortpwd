#!/usr/bin/env python
"""
Print the path of the working directory with long dirnames shortened.

If the whole path exceeds a certain length, it will be shortened by trimming
the individual directory names that form its path, by reducing them to a unique
prefix within their parent directory, or, failing that, by just cutting out
their middle part.
"""

from __future__ import division

import logging
import os
import pathlib
import sys
from itertools import chain, zip_longest

log = logging.getLogger(__name__)

DEBUG = False
"""Print debugging information to stderr."""

ABBREV = 'â€¦'
"""Replacement to use when shortening names"""

SHRINK_PATHS_BEYOND_LENGTH = 20
"""Paths shorter than this will not be shortened."""

SHRINK_NAMES_BEYOND_LENGTH = 4
"""When shortening a path, only shrink names which are longer than this."""

MIN_NAME_LENGTH = 2
"""When shortening a path, don't shrink individual names to less than this."""


def shorten(path):
    """Shorten a path by trimming the directory names it's made of."""
    path = pathlib.Path(path)
    return os.path.join(*(_shorten_parts(path)))


def _shorten_parts(path):
    samepath = pathlib.Path('.')
    paths = list(p for p in reversed(path.parents) if p != samepath) + [path]
    split = round(len(paths) / 2 + 0.25)  # index after middle
    assert split > 0
    from_left = paths[:split]
    from_right = list(reversed(paths[split:]))
    assert len(from_left) - len(from_right) in (0, 1)
    iter_inwards = chain.from_iterable(zip_longest(from_left, from_right))
    right = []
    for i, p in enumerate(iter_inwards):
        if p is None:
            break  # from_left was longer
        if i < 2:
            short = p.name or p.anchor  # don't shorten first and last part
        else:
            short = _shorten_name(p)
        # _debug(f'{maxlen:02}', repr(str(p)), repr(short))
        if i % 2 == 0:
            yield short
        else:
            right.append(short)
    yield from reversed(right)


def _shorten_name(path):
    maxlen = SHRINK_NAMES_BEYOND_LENGTH
    anchor, name = path.anchor, path.name
    namelen = len(name)
    if anchor and not name and path.parent == path:  # root path
        return anchor
    if maxlen is None or namelen <= maxlen or name == '~':
        return name
    assert namelen > maxlen
    return _find_unique_prefix(path, maxlen) or _abbrev(name, maxlen)


def _abbrev(name, maxlen):
    """Trim name by replacing its middle by an abbreviation string."""
    available = max(MIN_NAME_LENGTH, maxlen - len(ABBREV))
    _debug('abbrev', name=name, maxlen=maxlen)
    right_count = int(available / 2)
    left_count = available - right_count
    return name[:left_count] + ABBREV + name[len(name) - right_count:]


def _find_unique_prefix(path, maxlen):
    """Get shortest unique prefix of the pathname in its parent directory.

    For example, for `/path/to/some_name`, it will return the shortest prefix
    if `some_name` that is not shared by any other entry in the `/path/to`
    directory.

    Returns:
        The shortest prefix + the abbreviation string, or `None`.
    """
    name = path.name
    namelen = len(name)
    _debug('unique', name=name, maxlen=maxlen)
    siblings = list(_yield_sibling_names(path))
    assert name not in siblings
    sibling_prefixes = set(chain.from_iterable(
        _prefixes(s, maxlen=namelen) for s in siblings
    ))
    for prefix in _prefixes(name):
        if len(prefix) + len(ABBREV) >= namelen:
            return name
        if prefix not in sibling_prefixes:
            return prefix + ABBREV


def _yield_sibling_names(path):
    """Yield the names of other entries in the parent directory of a path"""
    path = path.expanduser()
    if path.parent.name == '.':
        return
    is_dir = None
    if path.exists():
        is_dir = path.is_dir()
        name = path.name
    for entry in os.scandir(path.parent):
        if (is_dir is None or entry.is_dir() == is_dir) and entry.name != name:
            yield entry.name


def _prefixes(string, minlen=None, maxlen=None):
    assert minlen is None or minlen >= 0
    strlen = len(string)
    maxlen = maxlen or strlen
    minlen = minlen or max(1, SHRINK_NAMES_BEYOND_LENGTH - len(ABBREV))
    minlen = min(minlen, maxlen)
    return (string[:n] for n in range(minlen, maxlen))


def _debug(*a, **kw):
    if DEBUG:
        things = a
        things += tuple(f'{k}={v!r}' for k, v in kw.items())
        print(*things, file=sys.stderr)


if __name__ == '__main__':
    cwd = os.getcwd()
    home = os.path.expanduser('~')
    if cwd.startswith(home):
        cwd = '~' + cwd[len(home):]
    if len(cwd) > SHRINK_PATHS_BEYOND_LENGTH:
        orig = cwd
        try:
            cwd = shorten(cwd)
        except Exception:
            log.exception('Error shrinking path %r', cwd)
        if DEBUG:
            cwdlen, origlen = len(cwd), len(orig)
            cwd = f'{cwd}|{cwdlen}|{cwdlen/origlen:.2}'
    print(cwd)
